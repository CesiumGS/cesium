{"version":3,"file":"OrientedBoundingBox-5c59eedb.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\r\nimport Cartesian2 from \"./Cartesian2.js\";\r\nimport Cartesian3 from \"./Cartesian3.js\";\r\nimport Cartographic from \"./Cartographic.js\";\r\nimport Check from \"./Check.js\";\r\nimport defaultValue from \"./defaultValue.js\";\r\nimport defined from \"./defined.js\";\r\nimport DeveloperError from \"./DeveloperError.js\";\r\nimport Ellipsoid from \"./Ellipsoid.js\";\r\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\r\nimport Intersect from \"./Intersect.js\";\r\nimport Interval from \"./Interval.js\";\r\nimport CesiumMath from \"./Math.js\";\r\nimport Matrix3 from \"./Matrix3.js\";\r\nimport Plane from \"./Plane.js\";\r\nimport Rectangle from \"./Rectangle.js\";\r\n\r\n/**\r\n * Creates an instance of an OrientedBoundingBox.\r\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n * @alias OrientedBoundingBox\r\n * @constructor\r\n *\r\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n *                                          cube centered at the origin.\r\n *\r\n *\r\n * @example\r\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n *\r\n * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n *\r\n * @see BoundingSphere\r\n * @see BoundingRectangle\r\n */\r\nfunction OrientedBoundingBox(center, halfAxes) {\r\n  /**\r\n   * The center of the box.\r\n   * @type {Cartesian3}\r\n   * @default {@link Cartesian3.ZERO}\r\n   */\r\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n  /**\r\n   * The transformation matrix, to rotate the box to the right position.\r\n   * @type {Matrix3}\r\n   * @default {@link Matrix3.ZERO}\r\n   */\r\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n}\r\n\r\n/**\r\n * The number of elements used to pack the object into an array.\r\n * @type {Number}\r\n */\r\nOrientedBoundingBox.packedLength =\r\n  Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {OrientedBoundingBox} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  Cartesian3.pack(value.center, array, startingIndex);\r\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n  return array;\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  Cartesian3.unpack(array, startingIndex, result.center);\r\n  Matrix3.unpack(\r\n    array,\r\n    startingIndex + Cartesian3.packedLength,\r\n    result.halfAxes\r\n  );\r\n  return result;\r\n};\r\n\r\nvar scratchCartesian1 = new Cartesian3();\r\nvar scratchCartesian2 = new Cartesian3();\r\nvar scratchCartesian3 = new Cartesian3();\r\nvar scratchCartesian4 = new Cartesian3();\r\nvar scratchCartesian5 = new Cartesian3();\r\nvar scratchCartesian6 = new Cartesian3();\r\nvar scratchCovarianceResult = new Matrix3();\r\nvar scratchEigenResult = {\r\n  unitary: new Matrix3(),\r\n  diagonal: new Matrix3(),\r\n};\r\n\r\n/**\r\n * Computes an instance of an OrientedBoundingBox of the given positions.\r\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n *\r\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n *\r\n * @example\r\n * // Compute an object oriented bounding box enclosing two points.\r\n * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n */\r\nOrientedBoundingBox.fromPoints = function (positions, result) {\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  if (!defined(positions) || positions.length === 0) {\r\n    result.halfAxes = Matrix3.ZERO;\r\n    result.center = Cartesian3.ZERO;\r\n    return result;\r\n  }\r\n\r\n  var i;\r\n  var length = positions.length;\r\n\r\n  var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n  for (i = 1; i < length; i++) {\r\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n  }\r\n  var invLength = 1.0 / length;\r\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n  var exx = 0.0;\r\n  var exy = 0.0;\r\n  var exz = 0.0;\r\n  var eyy = 0.0;\r\n  var eyz = 0.0;\r\n  var ezz = 0.0;\r\n  var p;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n    exx += p.x * p.x;\r\n    exy += p.x * p.y;\r\n    exz += p.x * p.z;\r\n    eyy += p.y * p.y;\r\n    eyz += p.y * p.z;\r\n    ezz += p.z * p.z;\r\n  }\r\n\r\n  exx *= invLength;\r\n  exy *= invLength;\r\n  exz *= invLength;\r\n  eyy *= invLength;\r\n  eyz *= invLength;\r\n  ezz *= invLength;\r\n\r\n  var covarianceMatrix = scratchCovarianceResult;\r\n  covarianceMatrix[0] = exx;\r\n  covarianceMatrix[1] = exy;\r\n  covarianceMatrix[2] = exz;\r\n  covarianceMatrix[3] = exy;\r\n  covarianceMatrix[4] = eyy;\r\n  covarianceMatrix[5] = eyz;\r\n  covarianceMatrix[6] = exz;\r\n  covarianceMatrix[7] = eyz;\r\n  covarianceMatrix[8] = ezz;\r\n\r\n  var eigenDecomposition = Matrix3.computeEigenDecomposition(\r\n    covarianceMatrix,\r\n    scratchEigenResult\r\n  );\r\n  var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n  var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n  var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n  var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n  var u1 = -Number.MAX_VALUE;\r\n  var u2 = -Number.MAX_VALUE;\r\n  var u3 = -Number.MAX_VALUE;\r\n  var l1 = Number.MAX_VALUE;\r\n  var l2 = Number.MAX_VALUE;\r\n  var l3 = Number.MAX_VALUE;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    p = positions[i];\r\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n  }\r\n\r\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n  var center = Cartesian3.add(v1, v2, result.center);\r\n  Cartesian3.add(center, v3, center);\r\n\r\n  var scale = scratchCartesian3;\r\n  scale.x = u1 - l1;\r\n  scale.y = u2 - l2;\r\n  scale.z = u3 - l3;\r\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\nvar scratchOffset = new Cartesian3();\r\nvar scratchScale = new Cartesian3();\r\nfunction fromPlaneExtents(\r\n  planeOrigin,\r\n  planeXAxis,\r\n  planeYAxis,\r\n  planeZAxis,\r\n  minimumX,\r\n  maximumX,\r\n  minimumY,\r\n  maximumY,\r\n  minimumZ,\r\n  maximumZ,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (\r\n    !defined(minimumX) ||\r\n    !defined(maximumX) ||\r\n    !defined(minimumY) ||\r\n    !defined(maximumY) ||\r\n    !defined(minimumZ) ||\r\n    !defined(maximumZ)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new OrientedBoundingBox();\r\n  }\r\n\r\n  var halfAxes = result.halfAxes;\r\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n  var centerOffset = scratchOffset;\r\n  centerOffset.x = (minimumX + maximumX) / 2.0;\r\n  centerOffset.y = (minimumY + maximumY) / 2.0;\r\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n  var scale = scratchScale;\r\n  scale.x = (maximumX - minimumX) / 2.0;\r\n  scale.y = (maximumY - minimumY) / 2.0;\r\n  scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n  var center = result.center;\r\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n  Cartesian3.add(planeOrigin, centerOffset, center);\r\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n  return result;\r\n}\r\n\r\nvar scratchRectangleCenterCartographic = new Cartographic();\r\nvar scratchRectangleCenter = new Cartesian3();\r\nvar scratchPerimeterCartographicNC = new Cartographic();\r\nvar scratchPerimeterCartographicNW = new Cartographic();\r\nvar scratchPerimeterCartographicCW = new Cartographic();\r\nvar scratchPerimeterCartographicSW = new Cartographic();\r\nvar scratchPerimeterCartographicSC = new Cartographic();\r\nvar scratchPerimeterCartesianNC = new Cartesian3();\r\nvar scratchPerimeterCartesianNW = new Cartesian3();\r\nvar scratchPerimeterCartesianCW = new Cartesian3();\r\nvar scratchPerimeterCartesianSW = new Cartesian3();\r\nvar scratchPerimeterCartesianSC = new Cartesian3();\r\nvar scratchPerimeterProjectedNC = new Cartesian2();\r\nvar scratchPerimeterProjectedNW = new Cartesian2();\r\nvar scratchPerimeterProjectedCW = new Cartesian2();\r\nvar scratchPerimeterProjectedSW = new Cartesian2();\r\nvar scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\nvar scratchPlaneOrigin = new Cartesian3();\r\nvar scratchPlaneNormal = new Cartesian3();\r\nvar scratchPlaneXAxis = new Cartesian3();\r\nvar scratchHorizonCartesian = new Cartesian3();\r\nvar scratchHorizonProjected = new Cartesian2();\r\nvar scratchMaxY = new Cartesian3();\r\nvar scratchMinY = new Cartesian3();\r\nvar scratchZ = new Cartesian3();\r\nvar scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n/**\r\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n * There are no guarantees about the orientation of the bounding box.\r\n *\r\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n *\r\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n */\r\nOrientedBoundingBox.fromRectangle = function (\r\n  rectangle,\r\n  minimumHeight,\r\n  maximumHeight,\r\n  ellipsoid,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(rectangle)) {\r\n    throw new DeveloperError(\"rectangle is required\");\r\n  }\r\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\r\n  }\r\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\r\n  }\r\n  if (\r\n    defined(ellipsoid) &&\r\n    !CesiumMath.equalsEpsilon(\r\n      ellipsoid.radii.x,\r\n      ellipsoid.radii.y,\r\n      CesiumMath.EPSILON15\r\n    )\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  minimumHeight = defaultValue(minimumHeight, 0.0);\r\n  maximumHeight = defaultValue(maximumHeight, 0.0);\r\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n  var minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n  if (rectangle.width <= CesiumMath.PI) {\r\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n    var tangentPointCartographic = Rectangle.center(\r\n      rectangle,\r\n      scratchRectangleCenterCartographic\r\n    );\r\n    var tangentPoint = ellipsoid.cartographicToCartesian(\r\n      tangentPointCartographic,\r\n      scratchRectangleCenter\r\n    );\r\n    var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n    plane = tangentPlane.plane;\r\n\r\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n    var lonCenter = tangentPointCartographic.longitude;\r\n    var latCenter =\r\n      rectangle.south < 0.0 && rectangle.north > 0.0\r\n        ? 0.0\r\n        : tangentPointCartographic.latitude;\r\n\r\n    // Compute XY extents using the rectangle at maximum height\r\n    var perimeterCartographicNC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNC\r\n    );\r\n    var perimeterCartographicNW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.north,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicNW\r\n    );\r\n    var perimeterCartographicCW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      latCenter,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicCW\r\n    );\r\n    var perimeterCartographicSW = Cartographic.fromRadians(\r\n      rectangle.west,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSW\r\n    );\r\n    var perimeterCartographicSC = Cartographic.fromRadians(\r\n      lonCenter,\r\n      rectangle.south,\r\n      maximumHeight,\r\n      scratchPerimeterCartographicSC\r\n    );\r\n\r\n    var perimeterCartesianNC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNC,\r\n      scratchPerimeterCartesianNC\r\n    );\r\n    var perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    var perimeterCartesianCW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicCW,\r\n      scratchPerimeterCartesianCW\r\n    );\r\n    var perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n    var perimeterCartesianSC = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSC,\r\n      scratchPerimeterCartesianSC\r\n    );\r\n\r\n    var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNC,\r\n      scratchPerimeterProjectedNC\r\n    );\r\n    var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianNW,\r\n      scratchPerimeterProjectedNW\r\n    );\r\n    var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianCW,\r\n      scratchPerimeterProjectedCW\r\n    );\r\n    var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSW,\r\n      scratchPerimeterProjectedSW\r\n    );\r\n    var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\r\n      perimeterCartesianSC,\r\n      scratchPerimeterProjectedSC\r\n    );\r\n\r\n    minX = Math.min(\r\n      perimeterProjectedNW.x,\r\n      perimeterProjectedCW.x,\r\n      perimeterProjectedSW.x\r\n    );\r\n    maxX = -minX; // symmetrical\r\n\r\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicNW,\r\n      scratchPerimeterCartesianNW\r\n    );\r\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\r\n      perimeterCartographicSW,\r\n      scratchPerimeterCartesianSW\r\n    );\r\n\r\n    minZ = Math.min(\r\n      Plane.getPointDistance(plane, perimeterCartesianNW),\r\n      Plane.getPointDistance(plane, perimeterCartesianSW)\r\n    );\r\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n    return fromPlaneExtents(\r\n      tangentPlane.origin,\r\n      tangentPlane.xAxis,\r\n      tangentPlane.yAxis,\r\n      tangentPlane.zAxis,\r\n      minX,\r\n      maxX,\r\n      minY,\r\n      maxY,\r\n      minZ,\r\n      maxZ,\r\n      result\r\n    );\r\n  }\r\n\r\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n  var fullyAboveEquator = rectangle.south > 0.0;\r\n  var fullyBelowEquator = rectangle.north < 0.0;\r\n  var latitudeNearestToEquator = fullyAboveEquator\r\n    ? rectangle.south\r\n    : fullyBelowEquator\r\n    ? rectangle.north\r\n    : 0.0;\r\n  var centerLongitude = Rectangle.center(\r\n    rectangle,\r\n    scratchRectangleCenterCartographic\r\n  ).longitude;\r\n\r\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n  var planeOrigin = Cartesian3.fromRadians(\r\n    centerLongitude,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchPlaneOrigin\r\n  );\r\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n  var isPole =\r\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\r\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n  var planeNormal = !isPole\r\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\r\n    : Cartesian3.UNIT_X;\r\n  var planeYAxis = Cartesian3.UNIT_Z;\r\n  var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\r\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n  var horizonCartesian = Cartesian3.fromRadians(\r\n    centerLongitude + CesiumMath.PI_OVER_TWO,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchHorizonCartesian\r\n  );\r\n  maxX = Cartesian3.dot(\r\n    Plane.projectPointOntoPlane(\r\n      plane,\r\n      horizonCartesian,\r\n      scratchHorizonProjected\r\n    ),\r\n    planeXAxis\r\n  );\r\n  minX = -maxX; // symmetrical\r\n\r\n  // Get the min and max Y, using the height that will give the largest extent\r\n  maxY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.north,\r\n    fullyBelowEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMaxY\r\n  ).z;\r\n  minY = Cartesian3.fromRadians(\r\n    0.0,\r\n    rectangle.south,\r\n    fullyAboveEquator ? minimumHeight : maximumHeight,\r\n    ellipsoid,\r\n    scratchMinY\r\n  ).z;\r\n\r\n  var farZ = Cartesian3.fromRadians(\r\n    rectangle.east,\r\n    latitudeNearestToEquator,\r\n    maximumHeight,\r\n    ellipsoid,\r\n    scratchZ\r\n  );\r\n  minZ = Plane.getPointDistance(plane, farZ);\r\n  maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n  // min and max are local to the plane axes\r\n  return fromPlaneExtents(\r\n    planeOrigin,\r\n    planeXAxis,\r\n    planeYAxis,\r\n    planeNormal,\r\n    minX,\r\n    maxX,\r\n    minY,\r\n    maxY,\r\n    minZ,\r\n    maxZ,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates a OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n */\r\nOrientedBoundingBox.clone = function (box, result) {\r\n  if (!defined(box)) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!defined(result)) {\r\n    return new OrientedBoundingBox(box.center, box.halfAxes);\r\n  }\r\n\r\n  Cartesian3.clone(box.center, result.center);\r\n  Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.intersectPlane = function (box, plane) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(plane)) {\r\n    throw new DeveloperError(\"plane is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var center = box.center;\r\n  var normal = plane.normal;\r\n  var halfAxes = box.halfAxes;\r\n  var normalX = normal.x,\r\n    normalY = normal.y,\r\n    normalZ = normal.z;\r\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n  var radEffective =\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\r\n    ) +\r\n    Math.abs(\r\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\r\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\r\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\r\n    );\r\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n  if (distanceToPlane <= -radEffective) {\r\n    // The entire box is on the negative side of the plane normal\r\n    return Intersect.OUTSIDE;\r\n  } else if (distanceToPlane >= radEffective) {\r\n    // The entire box is on the positive side of the plane normal\r\n    return Intersect.INSIDE;\r\n  }\r\n  return Intersect.INTERSECTING;\r\n};\r\n\r\nvar scratchCartesianU = new Cartesian3();\r\nvar scratchCartesianV = new Cartesian3();\r\nvar scratchCartesianW = new Cartesian3();\r\nvar scratchPPrime = new Cartesian3();\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {OrientedBoundingBox} box The box.\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\r\n  // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(cartesian)) {\r\n    throw new DeveloperError(\"cartesian is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n  var halfAxes = box.halfAxes;\r\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  var uHalf = Cartesian3.magnitude(u);\r\n  var vHalf = Cartesian3.magnitude(v);\r\n  var wHalf = Cartesian3.magnitude(w);\r\n\r\n  Cartesian3.normalize(u, u);\r\n  Cartesian3.normalize(v, v);\r\n  Cartesian3.normalize(w, w);\r\n\r\n  var pPrime = scratchPPrime;\r\n  pPrime.x = Cartesian3.dot(offset, u);\r\n  pPrime.y = Cartesian3.dot(offset, v);\r\n  pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n  var distanceSquared = 0.0;\r\n  var d;\r\n\r\n  if (pPrime.x < -uHalf) {\r\n    d = pPrime.x + uHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.x > uHalf) {\r\n    d = pPrime.x - uHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.y < -vHalf) {\r\n    d = pPrime.y + vHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.y > vHalf) {\r\n    d = pPrime.y - vHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  if (pPrime.z < -wHalf) {\r\n    d = pPrime.z + wHalf;\r\n    distanceSquared += d * d;\r\n  } else if (pPrime.z > wHalf) {\r\n    d = pPrime.z - wHalf;\r\n    distanceSquared += d * d;\r\n  }\r\n\r\n  return distanceSquared;\r\n};\r\n\r\nvar scratchCorner = new Cartesian3();\r\nvar scratchToCenter = new Cartesian3();\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.computePlaneDistances = function (\r\n  box,\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n\r\n  if (!defined(position)) {\r\n    throw new DeveloperError(\"position is required.\");\r\n  }\r\n\r\n  if (!defined(direction)) {\r\n    throw new DeveloperError(\"direction is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  if (!defined(result)) {\r\n    result = new Interval();\r\n  }\r\n\r\n  var minDist = Number.POSITIVE_INFINITY;\r\n  var maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n  var center = box.center;\r\n  var halfAxes = box.halfAxes;\r\n\r\n  var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n  var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n  var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n  // project first corner\r\n  var corner = Cartesian3.add(u, v, scratchCorner);\r\n  Cartesian3.add(corner, w, corner);\r\n  Cartesian3.add(corner, center, corner);\r\n\r\n  var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n  var mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project second corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project third corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fourth corner\r\n  Cartesian3.add(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project fifth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project sixth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.add(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project seventh corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.add(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  // project eighth corner\r\n  Cartesian3.subtract(center, u, corner);\r\n  Cartesian3.subtract(corner, v, corner);\r\n  Cartesian3.subtract(corner, w, corner);\r\n\r\n  Cartesian3.subtract(corner, position, toCenter);\r\n  mag = Cartesian3.dot(direction, toCenter);\r\n\r\n  minDist = Math.min(mag, minDist);\r\n  maxDist = Math.max(mag, maxDist);\r\n\r\n  result.start = minDist;\r\n  result.stop = maxDist;\r\n  return result;\r\n};\r\n\r\nvar scratchBoundingSphere = new BoundingSphere();\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.isOccluded = function (box, occluder) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (!defined(box)) {\r\n    throw new DeveloperError(\"box is required.\");\r\n  }\r\n  if (!defined(occluder)) {\r\n    throw new DeveloperError(\"occluder is required.\");\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  var sphere = BoundingSphere.fromOrientedBoundingBox(\r\n    box,\r\n    scratchBoundingSphere\r\n  );\r\n\r\n  return !occluder.isBoundingSphereVisible(sphere);\r\n};\r\n\r\n/**\r\n * Determines which side of a plane the oriented bounding box is located.\r\n *\r\n * @param {Plane} plane The plane to test against.\r\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n *                      intersects the plane.\r\n */\r\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\r\n  return OrientedBoundingBox.intersectPlane(this, plane);\r\n};\r\n\r\n/**\r\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n *\r\n * @param {Cartesian3} cartesian The point\r\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n *\r\n * @example\r\n * // Sort bounding boxes from back to front\r\n * boxes.sort(function(a, b) {\r\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n * });\r\n */\r\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\r\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n};\r\n\r\n/**\r\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n * <br>\r\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n * closest and farthest planes from position that intersect the bounding box.\r\n *\r\n * @param {Cartesian3} position The position to calculate the distance from.\r\n * @param {Cartesian3} direction The direction from position.\r\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n */\r\nOrientedBoundingBox.prototype.computePlaneDistances = function (\r\n  position,\r\n  direction,\r\n  result\r\n) {\r\n  return OrientedBoundingBox.computePlaneDistances(\r\n    this,\r\n    position,\r\n    direction,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Determines whether or not a bounding box is hidden from view by the occluder.\r\n *\r\n * @param {Occluder} occluder The occluder.\r\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n */\r\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\r\n  return OrientedBoundingBox.isOccluded(this, occluder);\r\n};\r\n\r\n/**\r\n * Compares the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.equals = function (left, right) {\r\n  return (\r\n    left === right ||\r\n    (defined(left) &&\r\n      defined(right) &&\r\n      Cartesian3.equals(left.center, right.center) &&\r\n      Matrix3.equals(left.halfAxes, right.halfAxes))\r\n  );\r\n};\r\n\r\n/**\r\n * Duplicates this OrientedBoundingBox instance.\r\n *\r\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n */\r\nOrientedBoundingBox.prototype.clone = function (result) {\r\n  return OrientedBoundingBox.clone(this, result);\r\n};\r\n\r\n/**\r\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n *\r\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n */\r\nOrientedBoundingBox.prototype.equals = function (right) {\r\n  return OrientedBoundingBox.equals(this, right);\r\n};\r\nexport default OrientedBoundingBox;\r\n"],"names":["Cartesian3","defaultValue","Matrix3","Check","defined","DeveloperError","Cartographic","Cartesian2","Plane","CesiumMath","Ellipsoid","Rectangle","EllipsoidTangentPlane","Intersect","Interval","BoundingSphere"],"mappings":"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"}