/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.109
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

import{a as N}from"./chunk-LV5JNJW5.js";import{a as ot}from"./chunk-5EYIWYCV.js";import{a as K,b as B}from"./chunk-TNR2OALX.js";import{a as k}from"./chunk-7OXYSRTX.js";import{a as F}from"./chunk-5AJJ3R5G.js";import{a as nt}from"./chunk-UQAIZ44P.js";import{a as et}from"./chunk-V2I3KQC6.js";import{b as Y,c as Q,d as H}from"./chunk-BCEMSXEQ.js";import{f as j}from"./chunk-EDXNYDRG.js";import{d as A}from"./chunk-BZH667V4.js";import{a as q}from"./chunk-73TRCFHO.js";import{a as b,b as W,c as tt,d as z}from"./chunk-CJUPDKMM.js";import{a as S}from"./chunk-RSM3RCYG.js";import{a as X}from"./chunk-3G6A2N63.js";import{e as w}from"./chunk-FZAERGXZ.js";function _(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(_.prototype,{length:{get:function(){return this._length}}});_.prototype.enqueue=function(n){this._array.push(n),this._length++};_.prototype.dequeue=function(){if(this._length===0)return;let n=this._array,s=this._offset,c=n[s];return n[s]=void 0,s++,s>10&&s*2>n.length&&(this._array=n.slice(s),s=0),this._offset=s,this._length--,c};_.prototype.peek=function(){if(this._length!==0)return this._array[this._offset]};_.prototype.contains=function(n){return this._array.indexOf(n)!==-1};_.prototype.clear=function(){this._array.length=this._offset=this._length=0};_.prototype.sort=function(n){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(n)};var J=_;var x={};x.computeHierarchyPackedLength=function(n,s){let c=0,f=[n];for(;f.length>0;){let u=f.pop();if(!w(u))continue;c+=2;let r=u.positions,t=u.holes;if(w(r)&&r.length>0&&(c+=r.length*s.packedLength),w(t)){let e=t.length;for(let o=0;o<e;++o)f.push(t[o])}}return c};x.packPolygonHierarchy=function(n,s,c,f){let u=[n];for(;u.length>0;){let r=u.pop();if(!w(r))continue;let t=r.positions,e=r.holes;if(s[c++]=w(t)?t.length:0,s[c++]=w(e)?e.length:0,w(t)){let o=t.length;for(let i=0;i<o;++i,c+=f.packedLength)f.pack(t[i],s,c)}if(w(e)){let o=e.length;for(let i=0;i<o;++i)u.push(e[i])}}return c};x.unpackPolygonHierarchy=function(n,s,c){let f=n[s++],u=n[s++],r=new Array(f),t=u>0?new Array(u):void 0;for(let e=0;e<f;++e,s+=c.packedLength)r[e]=c.unpack(n,s);for(let e=0;e<u;++e)t[e]=x.unpackPolygonHierarchy(n,s,c),s=t[e].startingIndex,delete t[e].startingIndex;return{positions:r,holes:t,startingIndex:s}};var M=new A;function rt(n,s,c,f){return A.subtract(s,n,M),A.multiplyByScalar(M,c/f,M),A.add(n,M,M),[M.x,M.y]}var G=new b;function ut(n,s,c,f){return b.subtract(s,n,G),b.multiplyByScalar(G,c/f,G),b.add(n,G,G),[G.x,G.y,G.z]}x.subdivideLineCount=function(n,s,c){let u=b.distance(n,s)/c,r=Math.max(0,Math.ceil(S.log2(u)));return Math.pow(2,r)};var Z=new W,$=new W,ht=new W,lt=new b,it=new F;x.subdivideRhumbLineCount=function(n,s,c,f){let u=n.cartesianToCartographic(s,Z),r=n.cartesianToCartographic(c,$),e=new F(u,r,n).surfaceDistance/f,o=Math.max(0,Math.ceil(S.log2(e)));return Math.pow(2,o)};x.subdivideTexcoordLine=function(n,s,c,f,u,r){let t=x.subdivideLineCount(c,f,u),e=A.distance(n,s),o=e/t,i=r;i.length=t*2;let a=0;for(let l=0;l<t;l++){let d=rt(n,s,l*o,e);i[a++]=d[0],i[a++]=d[1]}return i};x.subdivideLine=function(n,s,c,f){let u=x.subdivideLineCount(n,s,c),r=b.distance(n,s),t=r/u;w(f)||(f=[]);let e=f;e.length=u*3;let o=0;for(let i=0;i<u;i++){let a=ut(n,s,i*t,r);e[o++]=a[0],e[o++]=a[1],e[o++]=a[2]}return e};x.subdivideTexcoordRhumbLine=function(n,s,c,f,u,r,t){let e=c.cartesianToCartographic(f,Z),o=c.cartesianToCartographic(u,$);it.setEndPoints(e,o);let i=it.surfaceDistance/r,a=Math.max(0,Math.ceil(S.log2(i))),l=Math.pow(2,a),d=A.distance(n,s),m=d/l,p=t;p.length=l*2;let g=0;for(let h=0;h<l;h++){let y=rt(n,s,h*m,d);p[g++]=y[0],p[g++]=y[1]}return p};x.subdivideRhumbLine=function(n,s,c,f,u){let r=n.cartesianToCartographic(s,Z),t=n.cartesianToCartographic(c,$),e=new F(r,t,n),o=e.surfaceDistance/f,i=Math.max(0,Math.ceil(S.log2(o))),a=Math.pow(2,i),l=e.surfaceDistance/a;w(u)||(u=[]);let d=u;d.length=a*3;let m=0;for(let p=0;p<a;p++){let g=e.interpolateUsingSurfaceDistance(p*l,ht),h=n.cartographicToCartesian(g,lt);d[m++]=h.x,d[m++]=h.y,d[m++]=h.z}return d};var ft=new b,dt=new b,mt=new b,pt=new b;x.scaleToGeodeticHeightExtruded=function(n,s,c,f,u){f=X(f,tt.WGS84);let r=ft,t=dt,e=mt,o=pt;if(w(n)&&w(n.attributes)&&w(n.attributes.position)){let i=n.attributes.position.values,a=i.length/2;for(let l=0;l<a;l+=3)b.fromArray(i,l,e),f.geodeticSurfaceNormal(e,r),o=f.scaleToGeodeticSurface(e,o),t=b.multiplyByScalar(r,c,t),t=b.add(o,t,t),i[l+a]=t.x,i[l+1+a]=t.y,i[l+2+a]=t.z,u&&(o=b.clone(e,o)),t=b.multiplyByScalar(r,s,t),t=b.add(o,t,t),i[l]=t.x,i[l+1]=t.y,i[l+2]=t.z}return n};x.polygonOutlinesFromHierarchy=function(n,s,c){let f=[],u=new J;u.enqueue(n);let r,t,e;for(;u.length!==0;){let o=u.dequeue(),i=o.positions;if(s)for(e=i.length,r=0;r<e;r++)c.scaleToGeodeticSurface(i[r],i[r]);if(i=k(i,b.equalsEpsilon,!0),i.length<3)continue;let a=o.holes?o.holes.length:0;for(r=0;r<a;r++){let l=o.holes[r],d=l.positions;if(s)for(e=d.length,t=0;t<e;++t)c.scaleToGeodeticSurface(d[t],d[t]);if(d=k(d,b.equalsEpsilon,!0),d.length<3)continue;f.push(d);let m=0;for(w(l.holes)&&(m=l.holes.length),t=0;t<m;t++)u.enqueue(l.holes[t])}f.push(i)}return f};x.polygonsFromHierarchy=function(n,s,c,f,u){let r=[],t=[],e=new J;for(e.enqueue(n);e.length!==0;){let o=e.dequeue(),i=o.positions,a=o.holes,l,d;if(f)for(d=i.length,l=0;l<d;l++)u.scaleToGeodeticSurface(i[l],i[l]);if(s||(i=k(i,b.equalsEpsilon,!0)),i.length<3)continue;let m=c(i);if(!w(m))continue;let p=[],g=B.computeWindingOrder2D(m);g===K.CLOCKWISE&&(m.reverse(),i=i.slice().reverse());let h=i.slice(),y=w(a)?a.length:0,v=[],T;for(l=0;l<y;l++){let D=a[l],L=D.positions;if(f)for(d=L.length,T=0;T<d;++T)u.scaleToGeodeticSurface(L[T],L[T]);if(s||(L=k(L,b.equalsEpsilon,!0)),L.length<3)continue;let R=c(L);if(!w(R))continue;g=B.computeWindingOrder2D(R),g===K.CLOCKWISE&&(R.reverse(),L=L.slice().reverse()),v.push(L),p.push(h.length),h=h.concat(L),m=m.concat(R);let U=0;for(w(D.holes)&&(U=D.holes.length),T=0;T<U;T++)e.enqueue(D.holes[T])}r.push({outerRing:i,holes:v}),t.push({positions:h,positions2D:m,holes:p})}return{hierarchy:r,polygons:t}};var gt=new A,yt=new b,bt=new j,xt=new z;x.computeBoundingRectangle=function(n,s,c,f,u){let r=j.fromAxisAngle(n,f,bt),t=z.fromQuaternion(r,xt),e=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,l=c.length;for(let d=0;d<l;++d){let m=b.clone(c[d],yt);z.multiplyByVector(t,m,m);let p=s(m,gt);w(p)&&(e=Math.min(e,p.x),o=Math.max(o,p.x),i=Math.min(i,p.y),a=Math.max(a,p.y))}return u.x=e,u.y=i,u.width=o-e,u.height=a-i,u};x.createGeometryFromPositions=function(n,s,c,f,u,r,t){let e=B.triangulate(s.positions2D,s.holes);e.length<3&&(e=[0,1,2]);let o=s.positions,i=w(c),a=i?c.positions:void 0;if(u){let l=o.length,d=new Array(l*3),m=0;for(let h=0;h<l;h++){let y=o[h];d[m++]=y.x,d[m++]=y.y,d[m++]=y.z}let p={attributes:{position:new H({componentDatatype:q.DOUBLE,componentsPerAttribute:3,values:d})},indices:e,primitiveType:Y.TRIANGLES};i&&(p.attributes.st=new H({componentDatatype:q.FLOAT,componentsPerAttribute:2,values:A.packArray(a)}));let g=new Q(p);return r.normal?ot.computeNormal(g):g}if(t===N.GEODESIC)return B.computeSubdivision(n,o,e,a,f);if(t===N.RHUMB)return B.computeRhumbLineSubdivision(n,o,e,a,f)};var st=[],ct=[],wt=new b,Lt=new b;x.computeWallGeometry=function(n,s,c,f,u,r){let t,e,o,i,a,l,d,m,p,g=n.length,h=0,y=0,v=w(s),T=v?s.positions:void 0;if(u)for(e=g*3*2,t=new Array(e*2),v&&(p=g*2*2,m=new Array(p*2)),o=0;o<g;o++)i=n[o],a=n[(o+1)%g],t[h]=t[h+e]=i.x,++h,t[h]=t[h+e]=i.y,++h,t[h]=t[h+e]=i.z,++h,t[h]=t[h+e]=a.x,++h,t[h]=t[h+e]=a.y,++h,t[h]=t[h+e]=a.z,++h,v&&(l=T[o],d=T[(o+1)%g],m[y]=m[y+p]=l.x,++y,m[y]=m[y+p]=l.y,++y,m[y]=m[y+p]=d.x,++y,m[y]=m[y+p]=d.y,++y);else{let C=S.chordLength(f,c.maximumRadius),E=0;if(r===N.GEODESIC)for(o=0;o<g;o++)E+=x.subdivideLineCount(n[o],n[(o+1)%g],C);else if(r===N.RHUMB)for(o=0;o<g;o++)E+=x.subdivideRhumbLineCount(c,n[o],n[(o+1)%g],C);for(e=(E+g)*3,t=new Array(e*2),v&&(p=(E+g)*2,m=new Array(p*2)),o=0;o<g;o++){i=n[o],a=n[(o+1)%g];let P,I;v&&(l=T[o],d=T[(o+1)%g]),r===N.GEODESIC?(P=x.subdivideLine(i,a,C,ct),v&&(I=x.subdivideTexcoordLine(l,d,i,a,C,st))):r===N.RHUMB&&(P=x.subdivideRhumbLine(c,i,a,C,ct),v&&(I=x.subdivideTexcoordRhumbLine(l,d,c,i,a,C,st)));let at=P.length;for(let O=0;O<at;++O,++h)t[h]=P[O],t[h+e]=P[O];if(t[h]=a.x,t[h+e]=a.x,++h,t[h]=a.y,t[h+e]=a.y,++h,t[h]=a.z,t[h+e]=a.z,++h,v){let O=I.length;for(let V=0;V<O;++V,++y)m[y]=I[V],m[y+p]=I[V];m[y]=d.x,m[y+p]=d.x,++y,m[y]=d.y,m[y+p]=d.y,++y}}}g=t.length;let D=nt.createTypedArray(g/3,g-n.length*6),L=0;for(g/=6,o=0;o<g;o++){let C=o,E=C+1,P=C+g,I=P+1;i=b.fromArray(t,C*3,wt),a=b.fromArray(t,E*3,Lt),!b.equalsEpsilon(i,a,S.EPSILON10,S.EPSILON10)&&(D[L++]=C,D[L++]=P,D[L++]=E,D[L++]=E,D[L++]=P,D[L++]=I)}let R={attributes:new et({position:new H({componentDatatype:q.DOUBLE,componentsPerAttribute:3,values:t})}),indices:D,primitiveType:Y.TRIANGLES};return v&&(R.attributes.st=new H({componentDatatype:q.FLOAT,componentsPerAttribute:2,values:m})),new Q(R)};var Ut=x;export{Ut as a};
