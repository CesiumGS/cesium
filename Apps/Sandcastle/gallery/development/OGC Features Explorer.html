<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="Explore various collections of an OGC Features endpoint"
    />
    <meta name="cesium-sandcastle-labels" content="Development" />
    <title>OGC Features Explorer</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
    <style>
      @import url(../templates/bucket.css);
      #toolbar {
        background: rgba(42, 42, 42, 0.8);
        padding: 4px;
        border-radius: 4px;
      }
      #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
      }

      .input-wrapper {
        display: block;
        margin: 2px 3px;

        label + input {
          margin-left: 3px;
        }

        input[type="number"] {
          max-width: calc(7ch + 1rem);
        }
      }

      select {
        width: 100%;
      }

      #bbox-inputs {
        display: grid;
        grid-template-columns: auto auto auto;
        align-items: center;
        padding-left: 0.5em;
      }

      #status {
        position: absolute;
        display: inline-block;
        background: rgba(42, 42, 42, 0.8);
        padding: 0.5em;
        border-radius: 5px;
        top: 0;
        left: 100%;
        margin-left: 0.5em;
      }
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar">
      <div id="list"></div>
      <table>
        <tbody>
          <tr>
            <td>Provider</td>
            <td>
              <select
                class="cesium-button"
                data-bind="options: providers,
                          optionsText: 'name',
                          value: selectedProvider"
              ></select>
            </td>
          </tr>
          <tr>
            <td>Collection</td>
            <td>
              <select
                class="cesium-button"
                data-bind="options: collections,
                          optionsText: 'title',
                          value: selectedCollection,
                          enable: (collections.length > 0)"
              ></select>
            </td>
          </tr>
          <tr>
            <td>Limit</td>
            <td>
              <input
                type="range"
                min="0"
                max="10000"
                step="10"
                data-bind="value: limit, valueUpdate: 'input'"
              />
              <input
                type="number"
                min="0"
                max="10000"
                step="10"
                data-bind="value: limit"
              />
            </td>
          </tr>
          <tr>
            <td>Offset</td>
            <td>
              <input
                type="range"
                min="0"
                max="10000"
                step="10"
                data-bind="value: offset, valueUpdate: 'input', attr: { step: offsetStep }"
              />
              <input
                type="number"
                min="0"
                max="10000"
                step="10"
                data-bind="value: offset, attr: { step: offsetStep }"
              />
            </td>
          </tr>
          <tr>
            <td>
              <input type="checkbox" name="bbox" id="bbox" data-bind="checked: useBbox" />
              <label for="bbox">bbox</label>
            </td>
            <td id="bbox-inputs">
              <label>Upper left</label>
              <input
                type="text"
                id="bbox"
                size="6"
                data-bind="value: bboxUpperLeftLat, enable: useBbox"
              />
              <input
                type="text"
                id="bbox"
                size="6"
                data-bind="value: bboxUpperLeftLong, enable: useBbox"
              />
              <label>Lower right</label>
              <input
                type="text"
                id="bbox"
                size="6"
                data-bind="value: bboxLowerRightLat, enable: useBbox"
              />
              <input
                type="text"
                id="bbox"
                size="6"
                data-bind="value: bboxLowerRightLong, enable: useBbox"
              />
            </td>
          </tr>
        </tbody>
      </table>
      <output id="status">Initializing</output>
    </div>
    <script id="cesium_sandcastle_script">
      window.startup = async function (Cesium) {
        "use strict";
        // cspell:words ldproxy strassen daraa
        //Sandcastle_Begin
        const viewer = new Cesium.Viewer("cesiumContainer");
        const statusLabel = document.querySelector("#status");

        // Finland API:
        // Check out https://www.maanmittauslaitos.fi/en/rajapinnat/api-avaimen-ohje
        const finlandApiKey = "51cc1662-dc71-458e-9df3-c3d421bf18ed";
        const finlandProvider = {
          id: "finland",
          name: "Finland Geo Names (Points)",
          baseUrl:
            "https://avoin-paikkatieto.maanmittauslaitos.fi/geographic-names/features/v1",
          queryParams: {
            "api-key": finlandApiKey,
          },
        };

        // ldproxy API:
        const strassenProvider = {
          id: "strassen",
          name: "Strassen - German Roads (Points, Lines)",
          baseUrl: "https://demo.ldproxy.net/strassen",
          queryParams: {
            f: "json",
          },
        };
        const vinyardProvider = {
          id: "vinyard",
          name: "Vinyards - Germany (Areas)",
          baseUrl: "https://demo.ldproxy.net/vineyards",
          queryParams: {
            f: "json",
          },
        };
        const daraaProvider = {
          id: "daraa",
          name: "Daraa, Syria (Points, Lines, Areas)",
          baseUrl: "https://demo.ldproxy.net/daraa",
          queryParams: {
            f: "json",
          },
        };

        const providers = [
          strassenProvider,
          vinyardProvider,
          finlandProvider,
          daraaProvider,
        ];
        let currentProvider = strassenProvider;

        function translateName(name) {
          // Many of the ldproxy examples are in Germen so it's hard to know what they are
          // or what they represent or just talk about them. Translate some of the terms to eng
          // cspell:disable
          const translations = {
            "Abschnitte und Äste": "Sections and Branches",
            Netzknoten: "Network nodes",
            Nullpunkte: "Zero points",
            Unfälle: "Accidents",
            "Unfälle (alternative Darstellung)": "Accidents (alternative representation)",
          };
          // cspell:enable
          return translations[name] ?? name;
        }
        async function fetchCollections(baseUrl, options) {
          const { queryParams, headers } = options;
          const queryString = new URLSearchParams(queryParams);
          const response = await fetch(
            `${baseUrl}/collections${queryString && queryString !== "" && `?${queryString}`}`,
          );
          const json = await response.json();
          json.collections = json.collections.map((collection) => {
            collection.title = translateName(collection.title);
            return collection;
          });
          return json;
        }

        let loadedGeoJson;
        async function unload() {
          if (loadedGeoJson) {
            const removed = viewer.dataSources.remove(loadedGeoJson);
            if (removed) {
              loadedGeoJson = undefined;
            }
            console.log("geojson removed:", removed);
            return removed;
          }
          return true;
        }

        function createCollectionResource(baseUrl, collectionId, options = {}) {
          const resource = new Cesium.Resource({
            url: `${baseUrl}/collections/${collectionId}/items`,
          });
          const { queryParams, headers, limit, offset, bbox } = options;
          if (queryParams) {
            resource.setQueryParameters(queryParams);
          }
          if (headers) {
            resource.headers = headers;
          }
          if (Cesium.defined(limit) && limit > 0) {
            resource.appendQueryParameters({ limit });
          }
          if (Cesium.defined(offset) && offset > 0) {
            resource.appendQueryParameters({ offset });
          }
          if (bbox) {
            resource.appendQueryParameters({ bbox });
          }
          console.log("loading collection resource with", { limit, offset, bbox });

          // TODO: We _may_ want to do something like this to additionally request the data size
          // currently when the GeoJsonDataSource loads data it ignores/drops the extra properties
          // const collectionResource = resource.getDerivedResource({
          //   queryParameters: { limit: 1 },
          // });
          // const collectionJson = collectionResource.fetchJson().then((resp) => {
          //   console.log("response", resp);
          //   console.log("totalItems", resp.numberMatched);
          //   // This value is technically optional so some servers may not return it
          // });

          return resource;
        }

        let extendCollection = false;
        async function loadCollection(baseUrl, collectionId, options = {}) {
          if (!extendCollection) {
            const unloadedSuccessfully = unload();
            if (!unloadedSuccessfully) {
              statusLabel.innerText = "Error";
              console.log("Failed to unload previous dataSource");
              return;
            }
          }

          statusLabel.innerText = "Loading...";
          try {
            let createdNewDataSource = false;
            if (!extendCollection) {
              console.log("new geojson created");
              loadedGeoJson = new Cesium.GeoJsonDataSource();
              createdNewDataSource = true;
            } else if (!Cesium.defined(loadedGeoJson)) {
              console.log("new geojson created");
              loadedGeoJson = new Cesium.GeoJsonDataSource();
              createdNewDataSource = true;
            }
            const resource = createCollectionResource(baseUrl, collectionId, options);
            loadedGeoJson = await loadedGeoJson.process(resource, {
              preventDuplicates: true,
            });

            if (createdNewDataSource) {
              viewer.dataSources.add(loadedGeoJson);
            }
            viewer.zoomTo(loadedGeoJson);

            console.log("geojson", extendCollection ? "extended" : "updated");
            statusLabel.innerText = "Loaded";
          } catch (error) {
            statusLabel.innerText = "Failed to load";
            throw error;
          }
        }

        const collections = await fetchCollections(currentProvider.baseUrl, {
          queryParams: currentProvider.queryParams,
          headers: currentProvider.headers,
        });
        console.log(collections);

        let featureGeoJson;
        let limit = 10;
        let offset = 0;
        let useBbox = false;
        let bbox = "7.3978,51.5197,7.4190,51.5358";

        const viewModel = {
          providers: providers,
          selectedProvider: currentProvider,
          collections: collections.collections,
          selectedCollection: undefined,
          limit: limit,
          offset: offset,
          offsetStep: 10,
          useBbox: useBbox,
          bboxUpperLeftLat: "7.3978",
          bboxUpperLeftLong: "51.5197",
          bboxLowerRightLat: "7.4190",
          bboxLowerRightLong: "51.5358",
        };

        const bboxEntity = viewer.entities.add({
          rectangle: {
            coordinates: Cesium.Rectangle.fromDegrees(...bbox.split(",")),
            outline: true,
            outlineColor: Cesium.Color.RED,
            height: 0,
            material: Cesium.Color.PINK.withAlpha(0.5),
          },
          show: useBbox,
        });
        function updateBbox() {
          bbox = [
            viewModel.bboxUpperLeftLat,
            viewModel.bboxUpperLeftLong,
            viewModel.bboxLowerRightLat,
            viewModel.bboxLowerRightLong,
          ].join(",");
          const newCoords = bbox.split(",").map(Number.parseFloat);
          console.log("updating bbox to", bbox, newCoords);
          bboxEntity.rectangle.coordinates = Cesium.Rectangle.fromDegrees(...newCoords);
        }

        Sandcastle.addToolbarButton("Reload", () => {
          loadCollection(currentProvider.baseUrl, viewModel.selectedCollection.id, {
            queryParams: { ...currentProvider.queryParams },
            headers: currentProvider.headers,
            limit: limit,
            offset: offset,
            bbox: useBbox ? bbox : undefined,
          });
        });

        Cesium.knockout.track(viewModel);
        const toolbar = document.getElementById("toolbar");
        Cesium.knockout.applyBindings(viewModel, toolbar);

        Cesium.knockout
          .getObservable(viewModel, "selectedProvider")
          .subscribe(async (newValue) => {
            console.log("selected provider", newValue);
            currentProvider = newValue;
            viewModel.collections = [];
            const collections = await fetchCollections(currentProvider.baseUrl, {
              queryParams: currentProvider.queryParams,
              headers: currentProvider.headers,
            });
            viewModel.collections = collections.collections;
          });
        Cesium.knockout
          .getObservable(viewModel, "selectedCollection")
          .subscribe((newValue) => {
            if (!newValue) {
              // This will happen when we clear the list when switching providers
              return;
            }
            console.log("selected collection", newValue);
            try {
              // Reset page values
              limit = 10;
              offset = 0;
              viewModel.limit = 10;
              viewModel.offset = 0;
              viewModel.offsetStep = 10;

              // Load the collection
              loadCollection(currentProvider.baseUrl, newValue.id, {
                queryParams: { ...currentProvider.queryParams },
                headers: currentProvider.headers,
                limit: limit,
                offset: offset,
                bbox: useBbox ? bbox : undefined,
              });
            } catch (error) {
              console.error("failed to get feature service", error);
            }
          });
        // Set this after setting up the subscriptions so it loads the initial value
        viewModel.selectedCollection = collections.collections[0];
        Cesium.knockout.getObservable(viewModel, "limit").subscribe((newValue) => {
          limit = newValue;
          viewModel.offsetStep = newValue;
        });
        Cesium.knockout.getObservable(viewModel, "offset").subscribe((newValue) => {
          offset = newValue;
        });
        Cesium.knockout.getObservable(viewModel, "useBbox").subscribe((newValue) => {
          useBbox = newValue;
          bboxEntity.show = newValue;
        });
        Cesium.knockout
          .getObservable(viewModel, "bboxUpperLeftLat")
          .subscribe(updateBbox);
        Cesium.knockout
          .getObservable(viewModel, "bboxUpperLeftLong")
          .subscribe(updateBbox);
        Cesium.knockout
          .getObservable(viewModel, "bboxLowerRightLat")
          .subscribe(updateBbox);
        Cesium.knockout
          .getObservable(viewModel, "bboxLowerRightLong")
          .subscribe(updateBbox);

        Sandcastle.addToggleButton(
          "Extend current data",
          extendCollection,
          (newValue) => (extendCollection = newValue),
        );

        // TODO: remove
        window.cesiumViewer = viewer;

        //Sandcastle_End
      };
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        window.startup(Cesium).catch((error) => {
          "use strict";
          console.error(error);
        });
        Sandcastle.finishedLoading();
      }
    </script>
  </body>
</html>
