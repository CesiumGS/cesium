<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="Visualize worldwide, high-resolution terrain."
    />
    <meta name="cesium-sandcastle-labels" content="Development" />
    <title>ArcGIS Tiled Elevation Terrain Debug</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body
    class="sandcastle-loading"
    data-sandcastle-bucket="bucket-requirejs.html"
  >
    <style>
      @import url(../templates/bucket.css);
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar">
      <div id="pickTerrainProvider"></div>
      <div id="zoomButtons"></div>
      <div id="showOctreeLevel"></div>
      <div id="showTestedTriangles"></div>
      <div id="disableDefaultPickStrategy"></div>
      <div id="showOBB"></div>
      <table>
        <tbody>
          <tr>
            <td>Exaggeration</td>
            <td>
              <input
                type="range"
                min="0"
                max="10"
                step="0.01"
                data-bind="value: exaggeration, valueUpdate: 'input'"
              />
              <input type="text" size="5" data-bind="value: exaggeration" />
            </td>
          </tr>
          <tr>
            <td>Relative Height</td>
            <td>
              <input
                type="range"
                min="-1000"
                max="9000"
                step="1"
                data-bind="value: relativeHeight, valueUpdate: 'input'"
              />
              <input type="text" size="5" data-bind="value: relativeHeight" />
            </td>
          </tr>
        </tbody>
      </table>
      <script id="cesium_sandcastle_script">
        function startup(Cesium) {
          "use strict";

          //Sandcastle_Begin
          const worldTerrain = Cesium.createWorldTerrain({
            requestWaterMask: true,
            requestVertexNormals: true,
          });

          const arcGisTerrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider(
            {
              url:
                "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer",
            }
          );

          const locationOptions = [
            {
              name: "Mount Everest",
              target: new Cesium.Cartesian3(
                300770.50872389384,
                5634912.131394585,
                2978152.2865545116
              ),
              offset: new Cesium.Cartesian3(
                6344.974098678562,
                -793.3419798081741,
                2499.9508860763162
              ),
            },
            {
              name: "Half Dome",
              target: new Cesium.Cartesian3(
                -2489625.0836225147,
                -4393941.44443024,
                3882535.9454173897
              ),
              offset: new Cesium.Cartesian3(
                -6857.40902037546,
                412.3284835694358,
                2147.5545426812023
              ),
            },
            {
              name: "San Francisco Bay",
              target: new Cesium.Cartesian3(
                -2708814.85583248,
                -4254159.450845907,
                3891403.9457429945
              ),
              offset: new Cesium.Cartesian3(
                70642.66030209465,
                -31661.517948317807,
                35505.179997143336
              ),
            },
          ];

          const viewer = new Cesium.Viewer("cesiumContainer", {
            // terrainProvider: worldTerrain,
            terrainProvider: arcGisTerrainProvider,
          });
          viewer.scene.globe.enableLighting = false;
          viewer.scene.globe.terrainExaggeration = 1;
          // viewer.scene.globe.depthTestAgainstTerrain = false;
          viewer.scene.fog.enabled = false;

          window.viewer = viewer;

          const globe = viewer.scene.globe;

          const viewModel = {
            exaggeration: globe.terrainExaggeration,
            relativeHeight: globe.terrainExaggerationRelativeHeight,
          };

          function updateExaggeration() {
            globe.terrainExaggeration = Number(viewModel.exaggeration);
            globe.terrainExaggerationRelativeHeight = Number(
              viewModel.relativeHeight
            );
          }

          Cesium.knockout.track(viewModel);
          const toolbar = document.getElementById("toolbar");
          Cesium.knockout.applyBindings(viewModel, toolbar);
          for (const name in viewModel) {
            if (viewModel.hasOwnProperty(name)) {
              Cesium.knockout
                .getObservable(viewModel, name)
                .subscribe(updateExaggeration);
            }
          }

          Sandcastle.addToolbarButton("Remove Exaggeration", function () {
            viewModel.exaggeration = 1.0;
            viewModel.relativeHeight = 0.0;
          });

          let selectedOctreeLevel = null;
          let showTestedTriangles = false;
          let selectedShowOBB = false;

          const intersectedTriangleDataSource = new Cesium.CustomDataSource(
            "intersectedTriangleDataSource"
          );
          const testedTrianglesDataSource = new Cesium.CustomDataSource(
            "testedTrianglesDataSource"
          );
          const obbDataSource = new Cesium.CustomDataSource("obbDataSource");
          const axisPrimitiveCollection = new Cesium.PrimitiveCollection();
          const octreePrimitives = new Cesium.PrimitiveCollection();

          viewer.dataSources.add(intersectedTriangleDataSource);
          viewer.dataSources.add(testedTrianglesDataSource);
          viewer.dataSources.add(obbDataSource);
          viewer.scene.primitives.add(axisPrimitiveCollection);
          viewer.scene.primitives.add(octreePrimitives);

          function localToWorld(transform, local) {
            return Cesium.Matrix4.multiplyByPoint(
              transform,
              local,
              new Cesium.Cartesian3()
            );
          }

          function onTheFlyNodeAABB(level, x, y, z) {
            const sizeAtLevel = 1.0 / Math.pow(2, level);
            return {
              aabbMinX: x * sizeAtLevel - 0.5,
              aabbMaxX: (x + 1) * sizeAtLevel - 0.5,
              aabbCenterX: (x + 0.5) * sizeAtLevel - 0.5,
              aabbMinY: y * sizeAtLevel - 0.5,
              aabbMaxY: (y + 1) * sizeAtLevel - 0.5,
              aabbCenterY: (y + 0.5) * sizeAtLevel - 0.5,
              aabbMinZ: z * sizeAtLevel - 0.5,
              aabbMaxZ: (z + 1) * sizeAtLevel - 0.5,
              aabbCenterZ: (z + 0.5) * sizeAtLevel - 0.5,
            };
          }

          const colors = [
            "#e6194B",
            "#3cb44b",
            "#ffe119",
            "#4363d8",
            "#f58231",
            "#911eb4",
            "#42d4f4",
            "#f032e6",
          ];

          function drawOctreeNode(
            node,
            color,
            prims,
            transform,
            triangles,
            triangleVerticesCallback,
            isSpecial
          ) {
            const aabb = onTheFlyNodeAABB(node.level, node.x, node.y, node.z);
            const min = new Cesium.Cartesian3(
              aabb.aabbMinX,
              aabb.aabbMinY,
              aabb.aabbMinZ
            );
            const max = new Cesium.Cartesian3(
              aabb.aabbMaxX,
              aabb.aabbMaxY,
              aabb.aabbMaxZ
            );
            const box = new Cesium.BoxGeometry({
              maximum: max,
              minimum: min,
            });
            const outline = new Cesium.BoxOutlineGeometry({
              maximum: max,
              minimum: min,
            });

            if (isSpecial) {
              prims.add(
                new Cesium.Primitive({
                  asynchronous: false,
                  appearance: new Cesium.PerInstanceColorAppearance(),
                  geometryInstances: [
                    new Cesium.GeometryInstance({
                      geometry: box,
                      modelMatrix: transform,
                      attributes: {
                        color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                          color.withAlpha(0.2)
                        ),
                      },
                    }),
                  ],
                })
              );
            }
            prims.add(
              new Cesium.Primitive({
                asynchronous: false,
                appearance: new Cesium.PerInstanceColorAppearance({
                  translucent: false,
                  flat: true,
                }),
                geometryInstances: [
                  new Cesium.GeometryInstance({
                    geometry: outline,
                    modelMatrix: transform,
                    attributes: {
                      color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                        color.withAlpha(1)
                      ),
                    },
                  }),
                ],
              })
            );

            const trianglePolygons = [];
            const trianglePolygonOutlines = [];
            triangles = triangles || [];
            for (let i = 0; i < triangles.length; i++) {
              const triangleIdx = triangles[i];
              const v0 = new Cesium.Cartesian3();
              const v1 = new Cesium.Cartesian3();
              const v2 = new Cesium.Cartesian3();
              triangleVerticesCallback(triangleIdx, v0, v1, v2);

              const outlineGeometry = new Cesium.PolygonOutlineGeometry({
                polygonHierarchy: new Cesium.PolygonHierarchy([v0, v1, v2]),
                perPositionHeight: true,
              });
              const outlineInstance = new Cesium.GeometryInstance({
                geometry: outlineGeometry,
                attributes: {
                  color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                    color.withAlpha(1)
                  ),
                },
              });
              trianglePolygonOutlines.push(outlineInstance);

              const geometry = new Cesium.PolygonGeometry({
                polygonHierarchy: new Cesium.PolygonHierarchy([v0, v1, v2]),
                perPositionHeight: true,
              });
              const instance = new Cesium.GeometryInstance({
                geometry: geometry,
                attributes: {
                  color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                    color.withAlpha(0.7)
                  ),
                },
              });
              trianglePolygons.push(instance);
            }
            prims.add(
              new Cesium.Primitive({
                asynchronous: false,
                appearance: new Cesium.PerInstanceColorAppearance({
                  translucent: false,
                  flat: true,
                }),
                geometryInstances: trianglePolygonOutlines,
              })
            );
            prims.add(
              new Cesium.Primitive({
                asynchronous: false,
                appearance: new Cesium.PerInstanceColorAppearance({
                  translucent: true,
                  flat: true,
                }),
                geometryInstances: trianglePolygons,
              })
            );
          }

          function drawOctreeLayer(prims, level) {
            prims.removeAll();
            if (level === null || level === undefined) {
              return;
            }
            const root =
              window.lastPickDetails &&
              window.lastPickDetails.mesh &&
              window.lastPickDetails.mesh._octreeTrianglePicking;
            if (!root) {
              return;
            }

            const nodeHits =
              (window.lastPickDetails.traceDetails &&
                window.lastPickDetails.traceDetails.hits) ||
              [];

            const unpackedOctreeNodes = root._unpackedOctree;
            const transform = root._transform;
            const allNodes = flattenOctree(unpackedOctreeNodes[0]);
            const nodesToDraw = allNodes.filter(function (n) {
              return n.level === level;
            });

            let colorCycleIndex = 0;
            for (let j = 0; j < nodesToDraw.length; j++) {
              const n = nodesToDraw[j];
              const color = Cesium.Color.fromCssColorString(
                colors[colorCycleIndex % 8]
              );

              const isSpecial = nodeHits.some(function (h) {
                return (
                  h.level === n.level &&
                  h.x === n.x &&
                  h.y === n.y &&
                  h.z === n.z
                );
              });

              drawOctreeNode(
                n,
                color,
                prims,
                transform,
                n.intersectingTriangles,
                root._triangleVerticesCallback,
                isSpecial
              );
              colorCycleIndex++;
            }
          }

          function addDot(transform, local, color, radius, dataSource) {
            radius = radius || 50;
            const point = localToWorld(transform, local);
            dataSource.entities.add({
              position: point,
              ellipsoid: {
                radii: new Cesium.Cartesian3(radius, radius, radius),
                material: color,
              },
            });
          }

          function sortCartesianList(values) {
            return values.slice(0).sort(function (a, b) {
              return a.x - b.x;
            });
          }

          function isTriangleAlmostEqual(a, b) {
            a = sortCartesianList(a);
            b = sortCartesianList(b);
            return (
              isCartesianAlmostEqual(a[0], b[0]) &&
              isCartesianAlmostEqual(a[1], b[1]) &&
              isCartesianAlmostEqual(a[2], b[2])
            );
          }

          function isCartesianAlmostEqual(a, b) {
            return (
              a &&
              b &&
              Math.abs(a.x - b.x) < 0.1 &&
              Math.abs(a.y - b.y) < 0.1 &&
              Math.abs(a.z - b.z) < 0.1
            );
          }

          function drawTriangleList(color, dataSource, triangles) {
            if (triangles && triangles.length) {
              for (let i = 0; i < triangles.length; i++) {
                const tri = triangles[i];
                dataSource.entities.add({
                  polygon: {
                    hierarchy: tri.positions,
                    perPositionHeight: true,
                    material: color,
                    outline: true,
                    outlineColor: color,
                    outlineWidth: 10,
                  },
                });
              }
            }
          }

          Sandcastle.addDefaultToolbarMenu(
            locationOptions.map(function (option) {
              return {
                text: option.name,
                onselect: function () {
                  viewer.camera.lookAt(option.target, option.offset);
                  viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                },
              };
            }),
            "zoomButtons"
          );

          function flattenOctree(node) {
            return [node].concat((node.children || []).flatMap(flattenOctree));
          }

          function showIntersectedTriangles() {
            intersectedTriangleDataSource.entities.removeAll();
            const oldTriangle =
              window.lastPickDetails &&
              window.lastPickDetails.traceDetails &&
              window.lastPickDetails.traceDetails.oldIntersectedTriangle;
            const newTriangle =
              window.lastPickDetails &&
              window.lastPickDetails.traceDetails &&
              window.lastPickDetails.traceDetails.newIntersectedTriangle;

            if (
              oldTriangle &&
              newTriangle &&
              isTriangleAlmostEqual(oldTriangle, newTriangle)
            ) {
              drawTriangleList(
                Cesium.Color.GREEN,
                intersectedTriangleDataSource,
                [newTriangle]
              );
            } else {
              drawTriangleList(
                Cesium.Color.GOLD,
                intersectedTriangleDataSource,
                oldTriangle && [oldTriangle]
              );

              drawTriangleList(
                Cesium.Color.BLUE,
                intersectedTriangleDataSource,
                newTriangle && [newTriangle]
              );
            }
          }

          function setShowTestTriangles(value) {
            testedTrianglesDataSource.entities.removeAll();

            if (value) {
              const triangles =
                (window.lastPickDetails &&
                  window.lastPickDetails.traceDetails &&
                  window.lastPickDetails.traceDetails.trianglesTested) ||
                [];
              drawTriangleList(
                Cesium.Color.ORANGE,
                testedTrianglesDataSource,
                triangles
              );
            }
          }

          function showOBB(show, dataSource) {
            const transform =
              window.lastPickDetails &&
              window.lastPickDetails.mesh &&
              window.lastPickDetails.mesh._octreeTrianglePicking &&
              window.lastPickDetails.mesh._octreeTrianglePicking._transform;

            dataSource.entities.removeAll();
            if (!show || !transform) {
              return;
            }

            function c(x, y, z) {
              return new Cesium.Cartesian3(x, y, z);
            }

            const C = Cesium.Color;
            const radius =
              window.lastPickDetails.mesh.boundingSphere3D.radius / 50;

            let x;
            let y;
            let z;
            const amount = 0.2;
            for (x = -0.5; x <= 0.5; x += amount) {
              for (y = -0.5; y <= 0.5; y += amount) {
                for (z = -0.5; z <= 0.5; z += amount) {
                  let color = C.VIOLET;
                  if (x < 0 && y < 0) {
                    // TOP LEFT
                    color = C.BLUE;
                  }
                  if (x > 0 && y > 0) {
                    // BOTTOM RIGHT
                    color = C.ORANGE;
                  }
                  if (x < 0 && y > 0) {
                    // BOTTOM LEFT
                    color = C.GREEN;
                  }
                  if (x > 0 && y < 0) {
                    // TOP RIGHT
                    color = C.GOLD;
                  }
                  addDot(transform, c(x, y, z), color, radius, dataSource);
                }
              }
            }
          }

          function onSelectShowOctree(value) {
            selectedOctreeLevel = value;
            drawOctreeLayer(octreePrimitives, selectedOctreeLevel);
          }

          const showOctreeOptions = [
            {
              text: "Hide Octree",
              onselect: onSelectShowOctree.bind(this, null),
            },
          ];
          let optionLevel = 0;
          while (optionLevel <= 2) {
            showOctreeOptions.push({
              text: `Octree Level ${optionLevel}`,
              onselect: onSelectShowOctree.bind(this, optionLevel),
            });
            optionLevel++;
          }
          Sandcastle.addToolbarMenu(showOctreeOptions, "showOctreeLevel");

          Sandcastle.addToolbarMenu(
            [
              {
                text: "Enable Default Pick Strategy",
                onselect: function () {
                  window.disableDefaultPickStrategy = false;
                },
              },
              {
                text: "Disable Default Pick Strategy",
                onselect: function () {
                  window.disableDefaultPickStrategy = true;
                },
              },
            ],
            "disableDefaultPickStrategy"
          );
          window.disableDefaultPickStrategy = false;

          Sandcastle.addToolbarMenu(
            [
              {
                text: "ArcGIS Terrain",
                onselect: function () {
                  viewer.terrainProvider = arcGisTerrainProvider;
                },
              },
              {
                text: "Cesium World Terrain",
                onselect: function () {
                  viewer.terrainProvider = worldTerrain;
                },
              },
            ],
            "pickTerrainProvider"
          );
          viewer.terrainProvider = arcGisTerrainProvider;

          Sandcastle.addToolbarMenu(
            [
              {
                text: "Hide Tested Triangles",
                onselect: function () {
                  showTestedTriangles = false;
                  setShowTestTriangles(showTestedTriangles);
                },
              },
              {
                text: "Show Tested Triangles",
                onselect: function () {
                  showTestedTriangles = true;
                  setShowTestTriangles(showTestedTriangles);
                },
              },
            ],
            "showTestedTriangles"
          );

          Sandcastle.addToolbarMenu(
            [
              {
                text: "Hide Orientated Bounding Box",
                onselect: function () {
                  selectedShowOBB = false;
                  showOBB(selectedShowOBB, obbDataSource);
                },
              },
              {
                text: "Show Orientated Bounding Box",
                onselect: function () {
                  selectedShowOBB = true;
                  showOBB(selectedShowOBB, obbDataSource);
                },
              },
            ],
            "showOBB"
          );

          const scene = viewer.scene;
          const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

          handler.setInputAction(function (movement) {
            window.showPickDetails = true;
            const scene = viewer.scene;
            const camera = scene.camera;

            const ray = camera.getPickRay(movement.position);
            const pickPosition = scene.globe.pick(ray, scene);

            window.showPickDetails = false;

            const details = window.lastPickDetails;
            console.trace("stack trace here to debug the sandcastle script");

            if (details) {
              viewer.entities.removeAll();

              const transform = details.traceDetails.transform;
              const inverseTransform = details.traceDetails.inverseTransform;

              const axis = new Cesium.DebugModelMatrixPrimitive({
                modelMatrix: transform,
                length: 100000.0,
                width: 2.0,
              });
              axisPrimitiveCollection.removeAll();
              axisPrimitiveCollection.add(axis);

              viewer.entities.add({
                name: "ray",
                position: Cesium.Cartesian3.ZERO,
                polyline: {
                  positions: [ray.origin, Cesium.Ray.getPoint(ray, 10000)],
                  material: Cesium.Color.GOLDENROD,
                },
              });

              setShowTestTriangles(showTestedTriangles);
              showIntersectedTriangles();
              showOBB(selectedShowOBB, obbDataSource);

              drawOctreeLayer(octreePrimitives, selectedOctreeLevel);
            }
          }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

          //Sandcastle_End
          Sandcastle.finishedLoading();
        }
        if (typeof Cesium !== "undefined") {
          window.startupCalled = true;
          startup(Cesium);
        }
      </script>
    </div>
  </body>
</html>
