<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta name="description" content="Tiling Scheme example" />
    <meta name="cesium-sandcastle-labels" content="Development" />
    <title>Tiling Scheme</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
    <style>
      @import url(../templates/bucket.css);
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar"></div>
    <script id="cesium_sandcastle_script">
      window.startup = async function (Cesium) {
        "use strict";
        //Sandcastle_Begin
        const viewer = new Cesium.Viewer("cesiumContainer");

        function drawRect(rect, outlineColor = Cesium.Color.RED) {
          if (!rect) {
            return;
          }

          const rectEntity = viewer.entities.add({
            rectangle: {
              coordinates: rect,
              outline: true,
              outlineColor: outlineColor,
              height: 0,
              //material: Cesium.Color.PINK.withAlpha(0.5),
              //material: Cesium.Color.TRANSPARENT
              material: outlineColor.withAlpha(0.1),
            },
            show: true,
          });
          return rectEntity;
        }

        const usRect = new Cesium.Rectangle(
          -2.073804436865078,
          0.527119902096775,
          -1.4036981096114565,
          0.783288043816687,
        );

        const vineyardRect = new Cesium.Rectangle(
          0.10999300294631664,
          0.8553632074259329,
          0.14692013030297874,
          0.8833790886205592,
        );

        const targetRect = usRect;
        //const targetRect = vineyardRect;
        // const targetRect = Cesium.Rectangle.MAX_VALUE;
        const rectRatio =
          Cesium.Rectangle.computeWidth(targetRect) /
          Cesium.Rectangle.computeHeight(targetRect);

        const tilingScheme = new Cesium.GeographicTilingScheme({
          rectangle: targetRect,
          numberOfLevelZeroTilesX: Math.round(rectRatio),
          numberOfLevelZeroTilesY: 1,
        });
        console.log(tilingScheme);
        // For debugging/exploration in the console
        window.tilingScheme = tilingScheme;

        const scratchRect = new Cesium.Rectangle();

        Cesium.Rectangle.prototype.toString = function () {
          return `(${this.west}, ${this.south}, ${this.east}, ${this.north})`;
        };

        drawRect(tilingScheme.rectangle, Cesium.Color.LIME);

        const scratchPixelSize = new Cesium.Cartesian2();
        function getPixelSize() {
          // const canvas = viewer.scene.canvas;
          // const centerPixel = new Cesium.Cartesian2(
          //   canvas.clientWidth / 2.0,
          //   canvas.clientHeight / 2.0,
          // );
          // const ellipsoid = viewer.scene.ellipsoid;
          // const center = viewer.camera.pickEllipsoid(centerPixel, ellipsoid);

          // const pixelSize = viewer.camera.getPixelSize(
          //   new Cesium.BoundingSphere(center, 1),
          //   viewer.canvas.clientWidth,
          //   viewer.canvas.clientHeight,
          // );

          // alternative from only camera height
          const cameraHeight = viewer.camera.positionCartographic.height;
          const pixelDimensions = viewer.camera.frustum.getPixelDimensions(
            viewer.canvas.clientWidth,
            viewer.canvas.clientHeight,
            cameraHeight,
            viewer.scene.pixelRatio,
            scratchPixelSize,
          );
          const pixelSize = Math.max(pixelDimensions.x, pixelDimensions.y);

          return pixelSize;
        }

        function tileRectanglesInRectangle(tilingScheme, rect, level = 0) {
          // This is very similar to ImageryLayer._createTileImagerySkeletons
          if (!rect) {
            return [];
          }

          // use the intersection as the basis in case any points of rect are
          // outside the bounds of the tiling scheme
          const intersection = Cesium.Rectangle.intersection(
            rect,
            tilingScheme.rectangle,
          );

          const result = [];

          const northWest = Cesium.Rectangle.northwest(intersection);
          const southEast = Cesium.Rectangle.southeast(intersection);

          const posNW = tilingScheme.positionToTileXY(northWest, level);
          const posSE = tilingScheme.positionToTileXY(southEast, level);

          console.log({ posNW, posSE });

          const minX = posNW?.x ?? 0;
          const maxX = posSE?.x ?? tilingScheme.getNumberOfXTilesAtLevel(level) - 1;
          const minY = posNW?.y ?? 0;
          const maxY = posSE?.y ?? tilingScheme.getNumberOfYTilesAtLevel(level) - 1;

          // TODO: trim out south/east tiles if SE corner is near NW corner of SE most tile
          // TODO: trim out the north/west tiles if NW corner is near SE corner of NW most tile

          for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
              const tileRect = tilingScheme.tileXYToRectangle(x, y, level);
              result.push(tileRect);
              console.log(x, y, level, tileRect.toString());
            }
          }

          return result;
        }

        function rectangleWidth(rect) {
          // Check top and bottom due to curvature of the earth potentially causing
          // the width at the poles to be super small and not really representative
          const topWidth = Cesium.Cartesian3.distance(
            Cesium.Cartographic.toCartesian(Cesium.Rectangle.northwest(rect)),
            Cesium.Cartographic.toCartesian(Cesium.Rectangle.northeast(rect)),
          );
          const bottomWidth = Cesium.Cartesian3.distance(
            Cesium.Cartographic.toCartesian(Cesium.Rectangle.southwest(rect)),
            Cesium.Cartographic.toCartesian(Cesium.Rectangle.southeast(rect)),
          );
          return Math.max(topWidth, bottomWidth);
        }

        function rectangleHeight(rect) {
          return Cesium.Cartesian3.distance(
            Cesium.Cartographic.toCartesian(Cesium.Rectangle.northwest(rect)),
            Cesium.Cartographic.toCartesian(Cesium.Rectangle.southwest(rect)),
          );
        }

        function findTileLevel(tilingScheme, pixelSize) {
          for (let level = 0; level < 15; level++) {
            const levelTileRect = tilingScheme.tileXYToRectangle(
              level * 2,
              level * 2,
              level,
            );
            const width = rectangleWidth(levelTileRect);
            const pixelWidth = width / pixelSize;
            const height = rectangleHeight(levelTileRect);
            const pixelHeight = height / pixelSize;

            console.log({ pixelSize, width, pixelWidth, pixelHeight, level });
            if (Math.max(pixelWidth, pixelHeight) < 100) {
              // TODO: tune this number or pick a different method of deciding
              // If the rectangle would be smaller than X pixels return the level above it
              return Math.max(level - 1, 0);
            }
          }
          return 0;
        }

        Sandcastle.addToolbarButton("Show tiles in camera", (e) => {
          viewer.entities.removeAll();

          drawRect(tilingScheme.rectangle, Cesium.Color.LIME);

          const cameraRect = viewer.scene.camera.computeViewRectangle(
            viewer.scene.ellipsoid,
            scratchRect,
          );
          drawRect(cameraRect, Cesium.Color.YELLOW);

          const intersection = Cesium.Rectangle.intersection(
            cameraRect,
            tilingScheme.rectangle,
          );
          drawRect(intersection, Cesium.Color.PINK);

          const height = viewer.scene.camera.positionCartographic.height;
          let level = 0;

          const pickedLevel = findTileLevel(tilingScheme, getPixelSize());
          console.log("picked", pickedLevel);

          // TODO: this should be distance based to the target not height based
          // or maybe percentage based between coverage of the target bounds and the camera?
          if (height < 10000) {
            level = 4;
          } else if (height < 100000) {
            level = 3;
          } else if (height < 1000000) {
            level = 2;
          } else if (height < 5000000) {
            level = 1;
          }

          level = pickedLevel;

          console.log("camera", cameraRect.toString(), "height", height, "level", level);

          tileRectanglesInRectangle(tilingScheme, cameraRect, level).forEach((rect) => {
            drawRect(rect);
          });
        });

        //Sandcastle_End
      };
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        window.startup(Cesium).catch((error) => {
          "use strict";
          console.error(error);
        });
        Sandcastle.finishedLoading();
      }
    </script>
  </body>
</html>
