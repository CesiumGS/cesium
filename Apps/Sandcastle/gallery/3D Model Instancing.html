<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta name="description" content="Create 3D models using glTF." />
    <meta name="cesium-sandcastle-labels" content="Tutorials,Showcases" />
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
    <style>
      @import url(../templates/bucket.css);
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar"></div>
    <script id="cesium_sandcastle_script">
      window.startup = async function (Cesium) {
        "use strict";
        //Sandcastle_Begin
        const viewer = new Cesium.Viewer("cesiumContainer");

        const lng = -75.1652;
        const lat = 39.9526;
        const height = 30.0;

        let position;
        const headingPositionRoll = new Cesium.HeadingPitchRoll();
        const fixedFrameTransform = Cesium.Transforms.localFrameToFixedFrameGenerator(
          "north",
          "west",
        );

        let instanceModelMatrix;
        let instances = [];
        function genInstances() {
          const instances = [];
          let i;
          for (i = 0; i < 10; i++) {
            position = Cesium.Cartesian3.fromDegrees(
              lng + i * 0.0001,
              lat + i * 0.0001,
              height + i,
            );
            instanceModelMatrix = new Cesium.Transforms.headingPitchRollToFixedFrame(
              position,
              headingPositionRoll,
              Cesium.Ellipsoid.WGS84,
              fixedFrameTransform,
            );
            instances.push(new Cesium.ModelInstance(instanceModelMatrix));
          }
          return instances;
        }

        instances = genInstances();

        let model;
        try {
          model = await Cesium.Model.fromGltfAsync({
            //url: "../../SampleData/models/CesiumMan/Cesium_Man.glb",
            //url: "../../SampleData/models/storm_trooper/scene.gltf",
            //url : "../../SampleData/models/CesiumAir/Cesium_Air.glb",
            url: "../../SampleData/models/GroundVehicle/GroundVehicle.glb",
            //url: "../../SampleData/models/BoomBox.glb",
            //url: "../../SampleData/models/coffeeMug.glb",
            //url: "../../SampleData/models/CesiumBalloon/CesiumBalloon.glb",
            //url: "../../SampleData/models/CesiumMilkTruck/CesiumMilkTruck.glb",
            //modelMatrix: baseModelMatrix,
            minimumPixelSize: 128,
            instances: instances,
          });

          viewer.scene.primitives.add(model);
        } catch (error) {
          console.log(`Failed to load model. ${error}`);
        }

        const offset = new Cesium.Cartesian3(
          -37.048378684557974,
          -24.852967044804245,
          4.352023653686047,
        );

        const { Matrix4, BoundingSphere, Color } = Cesium;

        const removeListener = model.readyEvent.addEventListener(() => {
          const boundingSphere = model.boundingSphere;
          const modelSphere = viewer.entities.add({
            position: boundingSphere.center,
            ellipsoid: {
              radii: new Cesium.Cartesian3(
                boundingSphere.radius,
                boundingSphere.radius,
                boundingSphere.radius,
              ),
              material: Cesium.Color.WHITE.withAlpha(0.0),
              outline: true,
              outlineColor: Cesium.Color.WHITE,
            },
          });

          viewer.zoomTo(modelSphere);

          const sceneGraph = model.sceneGraph;
          const axisCorrectionMatrix = sceneGraph.axisCorrectionMatrix;
          const rootNodes = sceneGraph._rootNodes.map((i) => {
            return sceneGraph._runtimeNodes[i];
          });
          const rootTransform = sceneGraph.rootTransform;

          for (const instance of model.instances) {
            const instanceTransform = instance.transform;
            const rootModelMatrix = instance.computeModelMatrix(
              model.modelMatrix,
              rootTransform,
              new Matrix4(),
            );
            const rootBoundingSphere = sceneGraph.rootBoundingSphere;
            const boundingSphere = BoundingSphere.transform(
              rootBoundingSphere,
              rootModelMatrix,
            );
            const sphere = viewer.entities.add({
              position: boundingSphere.center,
              ellipsoid: {
                radii: new Cesium.Cartesian3(
                  boundingSphere.radius,
                  boundingSphere.radius,
                  boundingSphere.radius,
                ),
                material: Cesium.Color.GREEN.withAlpha(0.1),
                outline: true,
                outlineColor: Cesium.Color.GREEN,
              },
            });

            const createDebugBoundingSpheres = (nodes, color) => {
              for (const runtimeNode of nodes) {
                for (const primitive of runtimeNode.runtimePrimitives) {
                  const primitiveBoundingSphere = primitive.boundingSphere;
                  const boundingSphere = BoundingSphere.transform(
                    primitiveBoundingSphere,
                    rootModelMatrix,
                  );
                  const sphere = viewer.entities.add({
                    position: boundingSphere.center,
                    ellipsoid: {
                      radii: new Cesium.Cartesian3(
                        boundingSphere.radius,
                        boundingSphere.radius,
                        boundingSphere.radius,
                      ),
                      material: color.withAlpha(0.1),
                      outline: true,
                      outlineColor: color,
                    },
                  });
                }

                const childrenNodes = runtimeNode.children.map((i) => {
                  return sceneGraph._runtimeNodes[i];
                });
                createDebugBoundingSpheres(childrenNodes, Color.PURPLE);
              }
            };

            createDebugBoundingSpheres(rootNodes, Color.BLUE);
          }

          removeListener();
        });

        viewer.scene.camera.setView({
          destination: new Cesium.Cartesian3(
            1253512.5232461668,
            -4732922.214567729,
            4074115.474546098,
          ),
          orientation: new Cesium.HeadingPitchRoll(
            2.205737333179613,
            -0.7255022564055849,
            6.283181225638178,
          ),
        });
        //Sandcastle_End
      };
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        window.startup(Cesium).catch((error) => {
          "use strict";
          console.error(error);
        });
        Sandcastle.finishedLoading();
      }
    </script>
  </body>
</html>
