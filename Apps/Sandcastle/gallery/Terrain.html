<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="Visualize worldwide, high-resolution terrain."
    />
    <meta name="cesium-sandcastle-labels" content="Tutorials, Showcases" />
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>
  <body
    class="sandcastle-loading"
    data-sandcastle-bucket="bucket-requirejs.html"
  >
    <style>
      @import url(../templates/bucket.css);
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay"><h1>Loading...</h1></div>
    <div id="toolbar">
      <div id="terrainMenu"></div>
      <div id="zoomButtons"></div>
      <div id="showQuadtreeLevel"></div>
      <div id="showTestedTriangles"></div>
      <div id="showTileRectangle"></div>
      <div id="sampleButtons"></div>
      <div id="showOBB"></div>
    </div>
    <script id="cesium_sandcastle_script">
      function startup(Cesium) {
        "use strict";

        //Sandcastle_Begin
        var worldTerrain = Cesium.createWorldTerrain({
          requestWaterMask: true,
          requestVertexNormals: true,
        });

        var arcGisTerrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider(
          {
            url:
              "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer",
          }
        );

        var locationOptions = [
          {
            name: "Mount Everest",
            target: new Cesium.Cartesian3(
              300770.50872389384,
              5634912.131394585,
              2978152.2865545116
            ),
            offset: new Cesium.Cartesian3(
              6344.974098678562,
              -793.3419798081741,
              2499.9508860763162
            ),
          },
          {
            name: "Half Dome",
            target: new Cesium.Cartesian3(
              -2489625.0836225147,
              -4393941.44443024,
              3882535.9454173897
            ),
            offset: new Cesium.Cartesian3(
              -6857.40902037546,
              412.3284835694358,
              2147.5545426812023
            ),
          },
          {
            name: "San Francisco Bay",
            target: new Cesium.Cartesian3(
              -2708814.85583248,
              -4254159.450845907,
              3891403.9457429945
            ),
            offset: new Cesium.Cartesian3(
              70642.66030209465,
              -31661.517948317807,
              35505.179997143336
            ),
          },
        ];

        var viewer = new Cesium.Viewer("cesiumContainer", {
          terrainProvider: arcGisTerrainProvider,
        });
        viewer.scene.globe.enableLighting = false;
        // viewer.scene.globe.depthTestAgainstTerrain = false;
        viewer.scene.fog.enabled = false;

        window.viewer = viewer;

        var selectedQuadTreeAtLevel = null;
        var showTestedTriangles = false;
        var selectedShowTileRectangle = false;
        var selectedShowOBB = false;

        var tileRectDataSource = new Cesium.CustomDataSource(
          "tileRectDataSource"
        );
        var quadTreeDataSource = new Cesium.CustomDataSource("quadtree");

        var intersectedTriangleDataSource = new Cesium.CustomDataSource(
          "intersectedTriangleDataSource"
        );
        var testedTrianglesDataSource = new Cesium.CustomDataSource(
          "testedTrianglesDataSource"
        );
        var testedPointsDataSource = new Cesium.CustomDataSource(
          "testedPoints"
        );
        var obbDataSource = new Cesium.CustomDataSource("obbDataSource");
        var axisPrimitiveCollection = new Cesium.PrimitiveCollection();

        viewer.dataSources.add(quadTreeDataSource);
        viewer.dataSources.add(intersectedTriangleDataSource);
        viewer.dataSources.add(tileRectDataSource);
        viewer.dataSources.add(testedTrianglesDataSource);
        viewer.dataSources.add(testedPointsDataSource);
        viewer.dataSources.add(obbDataSource);
        viewer.scene.primitives.add(axisPrimitiveCollection);

        function localToWorld(transform, local) {
          return Cesium.Matrix4.multiplyByPoint(
            transform,
            local,
            new Cesium.Cartesian3()
          );
        }

        function drawQuadTreeNode(transform, node, obb, color) {
          var topLeft = node.topLeft;
          var bottomRight = node.bottomRight;
          var minHeight = node.minHeight;
          var maxHeight = node.maxHeight;

          var topLeftWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(topLeft.x, topLeft.y, 0)
          );
          var bottomRightWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(bottomRight.x, bottomRight.y, 0)
          );

          var minHeightWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(0, 0, minHeight)
          );
          var maxHeightWorldSpace = localToWorld(
            transform,
            new Cesium.Cartesian3(0, 0, maxHeight)
          );

          var topLeftCartographic = Cesium.Cartographic.fromCartesian(
            topLeftWorldSpace
          );
          var bottomRightCartographic = Cesium.Cartographic.fromCartesian(
            bottomRightWorldSpace
          );
          var minHeightCartographic = Cesium.Cartographic.fromCartesian(
            minHeightWorldSpace
          );
          var maxHeightCartographic = Cesium.Cartographic.fromCartesian(
            maxHeightWorldSpace
          );

          var rect = new Cesium.Rectangle(
            Math.min(
              topLeftCartographic.longitude,
              bottomRightCartographic.longitude
            ),
            Math.min(
              topLeftCartographic.latitude,
              bottomRightCartographic.latitude
            ),
            Math.max(
              bottomRightCartographic.longitude,
              topLeftCartographic.longitude
            ),
            Math.max(
              bottomRightCartographic.latitude,
              topLeftCartographic.latitude
            )
          );

          if (rect.north < rect.south) {
            console.warn("invalid node", rect, node);
            var tmp = rect.north;
            rect.north = rect.south;
            rect.south = tmp;
          }

          // if (rect.north < rect.south) {
          //   console.warn("invalid node", rect, node);
          //   var tmp = rect.north;
          //   rect.north = rect.south;
          //   rect.south = tmp;
          // }

          quadTreeDataSource.entities.add({
            rectangle: {
              coordinates: rect,
              material: color,
              rotation: Cesium.Math.toRadians(0),
              extrudedHeight: maxHeightCartographic.height,
              height: minHeightCartographic.height,
              outline: true, // height must be set for outline to display
              outlineColor: Cesium.Color.BLACK,
            },
          });
        }

        function addDot(transform, local, color, radius, dataSource) {
          radius = radius || 50;
          var point = localToWorld(transform, local);
          dataSource.entities.add({
            position: point,
            ellipsoid: {
              radii: new Cesium.Cartesian3(radius, radius, radius),
              material: color,
            },
          });
        }

        function drawPointList(color, dataSource, points) {
          if (points && points.length) {
            for (var i = 0; i < points.length; i++) {
              var p = points[i];
              dataSource.entities.add({
                position: p,
                ellipsoid: {
                  radii: new Cesium.Cartesian3(10000.0, 10000.0, 10000.0),
                  material: color,
                },
              });
            }
          }
        }

        function drawSphere(color, dataSource, spheres) {
          if (spheres && spheres.length) {
            for (var i = 0; i < spheres.length; i++) {
              var sphere = spheres[i];
              dataSource.entities.add({
                position: sphere.center,
                ellipsoid: {
                  radii: new Cesium.Cartesian3(
                    sphere.radius,
                    sphere.radius,
                    sphere.radius
                  ),
                  material: color,
                },
              });
            }
          }
        }

        function sortCartesianList(values) {
          return values.slice(0).sort(function (a, b) {
            return a.x - b.x;
          });
        }

        function isTriangleAlmostEqual(a, b) {
          a = sortCartesianList(a);
          b = sortCartesianList(b);
          return (
            isCartesianAlmostEqual(a[0], b[0]) &&
            isCartesianAlmostEqual(a[1], b[1]) &&
            isCartesianAlmostEqual(a[2], b[2])
          );
        }

        function isCartesianAlmostEqual(a, b) {
          return (
            a &&
            b &&
            Math.abs(a.x - b.x) < 0.1 &&
            Math.abs(a.y - b.y) < 0.1 &&
            Math.abs(a.z - b.z) < 0.1
          );
        }

        function drawTriangleList(color, dataSource, triangles) {
          if (triangles && triangles.length) {
            for (var i = 0; i < triangles.length; i++) {
              var tri = triangles[i];
              dataSource.entities.add({
                polygon: {
                  hierarchy: tri,
                  perPositionHeight: true,
                  material: color,
                  outline: true,
                  outlineColor: color,
                  outlineWidth: 10,
                },
              });
            }
          }
        }

        Sandcastle.addDefaultToolbarMenu(
          locationOptions.map(function (option) {
            return {
              text: option.name,
              onselect: function () {
                viewer.camera.lookAt(option.target, option.offset);
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
              },
            };
          }),
          "zoomButtons"
        );

        function flatten(node) {
          if (!node) {
            return [];
          }
          return [node]
            .concat(flatten(node.topLeftTree))
            .concat(flatten(node.bottomLeftTree))
            .concat(flatten(node.topRightTree))
            .concat(flatten(node.bottomRightTree));
        }

        function showIntersectedTriangles() {
          intersectedTriangleDataSource.entities.removeAll();
          var oldTriangle =
            window.lastPickDetails &&
            window.lastPickDetails.traceDetails &&
            window.lastPickDetails.traceDetails.oldIntersectedTriangle;
          var newTriangle =
            window.lastPickDetails &&
            window.lastPickDetails.traceDetails &&
            window.lastPickDetails.traceDetails.newIntersectedTriangle;

          if (
            oldTriangle &&
            newTriangle &&
            isTriangleAlmostEqual(oldTriangle, newTriangle)
          ) {
            drawTriangleList(
              Cesium.Color.GREEN,
              intersectedTriangleDataSource,
              [newTriangle]
            );
          } else {
            drawTriangleList(
              Cesium.Color.GOLD,
              intersectedTriangleDataSource,
              oldTriangle && [oldTriangle]
            );

            drawTriangleList(
              Cesium.Color.BLUE,
              intersectedTriangleDataSource,
              newTriangle && [newTriangle]
            );
          }
        }

        function setShowTestTriangles(value) {
          testedTrianglesDataSource.entities.removeAll();
          testedPointsDataSource.entities.removeAll();

          if (value) {
            var triangles =
              (window.lastPickDetails &&
                window.lastPickDetails.traceDetails &&
                window.lastPickDetails.traceDetails.testedTriangles) ||
              [];
            drawTriangleList(
              Cesium.Color.ORANGE,
              testedTrianglesDataSource,
              triangles
            );

            // var points =
            //   (window.lastPickDetails &&
            //     window.lastPickDetails.traceDetails &&
            //     window.lastPickDetails.traceDetails.testedPoints) ||
            //   [];
            // drawPointList(Cesium.Color.PINK, testedPointsDataSource, points);
          }
        }

        function drawRectangle(dataSource, rect) {
          dataSource.entities.add({
            id: "tile-rect",
            rectangle: {
              coordinates: rect,
              material: Cesium.Color.CYAN.withAlpha(0.5),
              rotation: Cesium.Math.toRadians(0),
              extrudedHeight: 10000,
              height: 0,
              outline: true,
              outlineColor: Cesium.Color.BLACK,
            },
          });
        }

        // function drawBoundingBox() {
        //   var obb =
        //     window.lastPickDetails &&
        //     window.lastPickDetails.mesh &&
        //     window.lastPickDetails.mesh._trianglePicking &&
        //     window.lastPickDetails.mesh._trianglePicking.obb;
        //   if (oob) {
        //     drawPointList(Cesium.Color.CYAN, testedTrianglesDataSource, [
        //       oob.center,
        //     ]);
        //   }
        // }

        function drawBoundingSphere() {
          var sphere =
            window.lastPickDetails &&
            window.lastPickDetails.mesh &&
            window.lastPickDetails.mesh._trianglePicking &&
            window.lastPickDetails.mesh._trianglePicking.sphere;
          if (sphere) {
            drawSphere(
              Cesium.Color.ORANGE.withAlpha(0.1),
              testedTrianglesDataSource,
              [sphere]
            );
          }
        }

        function showTileRectangle(show) {
          var rect =
            window.lastPickDetails &&
            window.lastPickDetails.mesh &&
            window.lastPickDetails.mesh._trianglePicking &&
            window.lastPickDetails.mesh._trianglePicking._rectangle;
          tileRectDataSource.entities.removeAll();
          if (rect && show) {
            drawRectangle(tileRectDataSource, rect);
          }
        }

        function showOBB(show, dataSource) {
          dataSource.entities.removeAll();
          if (!show) {
            return;
          }

          function c(x, y, z) {
            return new Cesium.Cartesian3(x, y, z);
          }

          var C = Cesium.Color;
          var transform = window.lastPickDetails.traceDetails.transform;

          var x;
          var y;
          var z;
          for (x = -0.5; x <= 0.5; x += 0.1) {
            for (y = -0.5; y <= 0.5; y += 0.1) {
              for (z = -0.5; z <= 0.5; z += 0.1) {
                var color = C.VIOLET;
                if (x < 0 && y < 0) {
                  // TOP LEFT
                  color = C.BLUE;
                }
                if (x > 0 && y > 0) {
                  // BOTTOM RIGHT
                  color = C.ORANGE;
                }
                if (x < 0 && y > 0) {
                  // BOTTOM LEFT
                  color = C.GREEN;
                }
                if (x > 0 && y < 0) {
                  // TOP RIGHT
                  color = C.GOLD;
                }
                addDot(transform, c(x, y, z), color, 50000, dataSource);
              }
            }
          }
        }

        function showQuadTreeAtLevel(level) {
          if (window.lastPickDetails) {
            var root = window.lastPickDetails.mesh._trianglePicking._quadtree;
            var transform = window.lastPickDetails.traceDetails.transform;
            var obb = window.lastPickDetails.mesh._trianglePicking.obb;

            var nodes = flatten(root);
            var nodesAtLevel = nodes.filter(function (n) {
              return n.level === level;
            });

            quadTreeDataSource.entities.removeAll();
            for (var i = 0; i < nodesAtLevel.length; i++) {
              var n = nodesAtLevel[i];
              var color = Cesium.Color.GREEN.withAlpha(0.4);
              if (n.isHit) {
                color = Cesium.Color.GOLD.withAlpha(0.4);
              }
              drawQuadTreeNode(transform, n, obb, color);
            }
          }
        }

        function getShowAtLevelFn(level) {
          return function () {
            selectedQuadTreeAtLevel = level;
            showQuadTreeAtLevel(selectedQuadTreeAtLevel);
          };
        }

        var showQuadTreeOptions = [
          {
            text: "Hide Quadtree",
            onselect: getShowAtLevelFn(null),
          },
        ];
        var optionLevel = 0;
        while (optionLevel < 6) {
          showQuadTreeOptions.push({
            text: "Quadtree Level " + optionLevel,
            onselect: getShowAtLevelFn(optionLevel),
          });
          optionLevel++;
        }

        Sandcastle.addToolbarMenu(showQuadTreeOptions, "showQuadtreeLevel");
        Sandcastle.addToolbarMenu(
          [
            {
              text: "Hide Tested Triangles",
              onselect: function () {
                showTestedTriangles = false;
                setShowTestTriangles(showTestedTriangles);
              },
            },
            {
              text: "Show Tested Triangles",
              onselect: function () {
                showTestedTriangles = true;
                setShowTestTriangles(showTestedTriangles);
              },
            },
          ],
          "showTestedTriangles"
        );
        Sandcastle.addToolbarMenu(
          [
            {
              text: "Hide Orientated Bounding Box",
              onselect: function () {
                selectedShowOBB = false;
                showOBB(selectedShowOBB, obbDataSource);
              },
            },
            {
              text: "Show Orientated Bounding Box",
              onselect: function () {
                selectedShowOBB = true;
                showOBB(selectedShowOBB, obbDataSource);
              },
            },
          ],
          "showOBB"
        );

        Sandcastle.addToolbarMenu(
          [
            {
              text: "Hide Tile Rectangle",
              onselect: function () {
                selectedShowTileRectangle = false;
                showTileRectangle(selectedShowTileRectangle);
              },
            },
            {
              text: "Show Tile Rectangle",
              onselect: function () {
                selectedShowTileRectangle = true;
                showTileRectangle(selectedShowTileRectangle);
              },
            },
          ],
          "showTileRectangle"
        );

        var scene = viewer.scene;
        var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

        handler.setInputAction(function (movement) {
          window.showPickDetails = true;
          var scene = viewer.scene;
          var camera = scene.camera;

          var ray = camera.getPickRay(movement.position);
          var pickPosition = scene.globe.pick(ray, scene);

          window.showPickDetails = false;

          var details = window.lastPickDetails;
          console.trace("details here");

          if (details) {
            viewer.entities.removeAll();

            debugger;
            var transform = details.traceDetails.transform;
            var inverseTransform = details.traceDetails.inverseTransform;

            var axis = new Cesium.DebugModelMatrixPrimitive({
              modelMatrix: transform,
              length: 100000.0,
              width: 2.0,
            });
            axisPrimitiveCollection.removeAll();
            axisPrimitiveCollection.add(axis);

            viewer.entities.add({
              name: "ray",
              position: Cesium.Cartesian3.ZERO,
              polyline: {
                positions: [ray.origin, Cesium.Ray.getPoint(ray, 10000)],
                material: Cesium.Color.GOLDENROD,
              },
            });

            setShowTestTriangles(showTestedTriangles);
            showIntersectedTriangles();
            showQuadTreeAtLevel(selectedQuadTreeAtLevel);
            showTileRectangle(selectedShowTileRectangle);
            showOBB(selectedShowOBB, obbDataSource);
          }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        //Sandcastle_End
        Sandcastle.finishedLoading();
      }
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        startup(Cesium);
      }
    </script>
  </body>
</html>
